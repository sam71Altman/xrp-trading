# =========================================================
# STAGE-1 â€” ATOMIC CORE (FINAL SAFE MINIMAL)
# MODIFY EXISTING TradingEngine ONLY
# =========================================================

import asyncio
import logging

logger = logging.getLogger(__name__)


# =========================================================
# ADD INSIDE TradingEngine.__init__
# =========================================================

self._trade_lock = asyncio.Lock()
self._trade_queue = asyncio.Queue(maxsize=1)

# ---- Single Source of Truth ----
self._position_open = False
self._position_symbol = None
self._entry_price = 0.0
self._position_version = 0

self._last_trade_id = None
self._pipeline_task = None


# =========================================================
# STRATEGIES ENTRY POINT (ONLY THIS)
# =========================================================

async def request_trade(self, signal):
    """
    Wait briefly instead of dropping immediately.
    Prevents silent signal loss.
    """
    try:
        async with asyncio.timeout(1.0):
            await self._trade_queue.put(signal)
            return True
    except asyncio.TimeoutError:
        return False


# =========================================================
# SINGLE PIPELINE (NEVER DIES)
# =========================================================

async def _trade_pipeline(self):

    while True:
        try:
            try:
                async with asyncio.timeout(1.0):
                    signal = await self._trade_queue.get()
            except asyncio.TimeoutError:
                continue

            await self._execute_trade_atomically(signal)

            self._trade_queue.task_done()

        except Exception:
            logger.exception("[Pipeline crash prevented]")


# =========================================================
# SINGLE EXECUTION POINT
# =========================================================

async def _execute_trade_atomically(self, signal):

    try:
        async with asyncio.timeout(0.5):
            async with self._trade_lock:
                return await self._execute_under_lock(signal)
    except asyncio.TimeoutError:
        return False


# =========================================================
# ATOMIC EXECUTION (ALL SIDE EFFECTS INSIDE LOCK)
# =========================================================

async def _execute_under_lock(self, signal):

    # ================= OPEN =================
    if signal.type == "OPEN":

        if self._position_open:
            return False

        try:
            async with asyncio.timeout(3.0):
                order = await self.broker.order(
                    signal.symbol,
                    "BUY",
                    signal.amount
                )
        except asyncio.TimeoutError:
            return False

        # ----- atomic state -----
        self._position_open = True
        self._position_symbol = signal.symbol
        self._entry_price = order.price
        self._position_version += 1

        # ----- telegram INSIDE lock (CRITICAL FIX) -----
        await self._notify_trade_once(order)

        return True


    # ================= CLOSE =================
    elif signal.type == "CLOSE":

        if not self._position_open:
            return False

        try:
            async with asyncio.timeout(3.0):
                order = await self.broker.order(
                    self._position_symbol,
                    "SELL",
                    signal.amount
                )
        except asyncio.TimeoutError:
            return False

        # ----- atomic state -----
        self._position_open = False
        self._position_symbol = None
        self._entry_price = 0.0
        self._position_version += 1

        await self._notify_trade_once(order)

        return True

    return False


# =========================================================
# SINGLE NOTIFICATION (ATOMIC)
# =========================================================

async def _notify_trade_once(self, order):

    if order.id == self._last_trade_id:
        return

    message = f"{order.side} {order.symbol} @ {order.price}"

    try:
        await self.telegram.send(message)
        self._last_trade_id = order.id
    except Exception:
        logger.exception("Telegram send failed")


# =========================================================
# START CORE
# =========================================================

async def start_trading_core(self):

    if not self._pipeline_task:
        self._pipeline_task = asyncio.create_task(self._trade_pipeline())