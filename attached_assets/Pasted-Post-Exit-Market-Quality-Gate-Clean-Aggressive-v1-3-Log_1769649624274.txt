Post-Exit Market Quality Gate

(Clean Aggressive v1.3 â€“ Logic Corrected)

âš ï¸ ØªÙ†Ø¨ÙŠÙ‡ Ø¥Ù„Ø²Ø§Ù…ÙŠ Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°

Ù‡Ø°Ø§ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù„ÙŠØ³:
âŒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
âŒ ØªØºÙŠÙŠØ± Ø´Ø±ÙˆØ· Ø§Ù„Ø¯Ø®ÙˆÙ„
âŒ ØªØºÙŠÙŠØ± EMA / SL / TP
âŒ Ø¥Ø¶Ø§ÙØ© Ù…Ø¤Ø´Ø±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
âŒ Ø¥Ø¶Ø§ÙØ© cooldown Ø²Ù…Ù†ÙŠ Ø«Ø§Ø¨Øª
âŒ ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© Ø§Ù„Ø¨ÙˆØª

Ù‡Ø°Ø§ Ø¥ØµÙ„Ø§Ø­ Ø³Ù„ÙˆÙƒÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙ‚Ø·.

ğŸ¯ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙˆØ­ÙŠØ¯

Ù…Ù†Ø¹ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ØºØ¨ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙŠ Ø³ÙˆÙ‚:

Â· Ø¶Ø¹ÙŠÙ
Â· Ø¬Ø§Ù†Ø¨ÙŠ
Â· Ø¨Ø¯ÙˆÙ† Ø§Ø±ØªØ¯Ø§Ø¯ Ø­Ù‚ÙŠÙ‚ÙŠ

Ù…Ø¹ Ø§Ù„Ø³Ù…Ø§Ø­ Ø§Ù„ÙÙˆØ±ÙŠ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ø¥Ø´Ø§Ø±Ø© ØªØ¹Ø§ÙÙŠ Ø­Ù‚ÙŠÙ‚ÙŠØ©.

ğŸ” Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø§Ù„ØªÙŠ ÙŠØ¹Ø§Ù„Ø¬Ù‡Ø§ Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙ‚Ø·

```
Exit ØµØ­ÙŠØ­  
â†“  
Re-Enter Ù…Ø¨Ø§Ø´Ø±  
â†“  
Ø§Ù„Ø³ÙˆÙ‚ Ù„Ù… ÙŠØªØ¹Ø§ÙÙ  
â†“  
ØµÙÙ‚Ø© Ø®Ø§Ø³Ø±Ø© / Ø±Ø¨Ø­ ØªØ§ÙÙ‡
```

ğŸ§  Ø§Ù„ÙÙ„Ø³ÙØ© (Ø«Ø§Ø¨ØªØ© â€“ Ù„Ø§ Ù†Ù‚Ø§Ø´)

Ù‚Ø±Ø§Ø± Ø«Ù†Ø§Ø¦ÙŠ ÙÙ‚Ø·:

Â· Enter âœ…
Â· Block âŒ

âŒ Ù„Ø§ Partial
âŒ Ù„Ø§ Penalty
âŒ Ù„Ø§ Multiplier
âŒ Ù„Ø§ ÙÙ„Ø³ÙØ© Ø±Ù‚Ù…ÙŠØ©

ğŸ—ï¸ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨

1ï¸âƒ£ Ø­Ø§Ø±Ø³ Ø®ÙÙŠÙ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ (Post-Exit Guard)

```python
# ğŸ“ post_exit_guard.py

class PostExitGuard:
    """
    Ø­Ø§Ø±Ø³ Ø®ÙÙŠÙ ÙŠÙ…Ù†Ø¹ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙÙŠ Ø³ÙˆÙ‚ ØºÙŠØ± Ù…ØªØ¹Ø§ÙÙ
    """
    _instance = None
    MAX_BLOCK_DURATION = 3600  # 1 Ø³Ø§Ø¹Ø© (Ø­Ù…Ø§ÙŠØ© ÙÙ‚Ø·)

    @classmethod
    def get(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    def __init__(self):
        self.active = False
        self.exit_price = None
        self.exit_time = None
        
        # ğŸ“Š Ø¥Ø­ØµØ§Ø¡Ø§Øª Ù„Ù„Ù‚Ø±Ø§Ø¡Ø© ÙÙ‚Ø· (Ù„Ø§ ØªØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª)
        self._stats = {
            "entries_blocked": 0,
            "entries_allowed": 0,
            "total_block_duration": 0.0,
            "clear_reasons": {},
            "recovery_reasons": {}
        }

    def record_exit(self, exit_price, timestamp):
        """ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬ Ø¬Ø¯ÙŠØ¯"""
        self.active = True
        self.exit_price = exit_price
        self.exit_time = timestamp
        log(f"[PEG] Exit recorded @ {exit_price}")

    def clear(self, reason):
        """Ù…Ø³Ø­ Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ø±Ø³"""
        if self.active:
            # Ø­Ø³Ø§Ø¨ Ù…Ø¯Ø© Ø§Ù„Ù…Ù†Ø¹ ÙÙ‚Ø· Ù„Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            if self.exit_time:
                block_duration = now() - self.exit_time
                self._stats["total_block_duration"] += block_duration
            
            # ØªØ³Ø¬ÙŠÙ„ Ø³Ø¨Ø¨ Ø§Ù„Ø¥Ø²Ø§Ù„Ø©
            self._stats["clear_reasons"][reason] = self._stats["clear_reasons"].get(reason, 0) + 1
            
            log(f"[PEG] Cleared | reason={reason}")
        
        self.active = False
        self.exit_price = None
        self.exit_time = None

    def expired(self):
        """Ù‡Ù„ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø§Ø±Ø³ØŸ"""
        if not self.active or self.exit_time is None:
            return False
        return (now() - self.exit_time) > self.MAX_BLOCK_DURATION
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # ğŸ“Š Ø·Ø±Ù‚ Ø§Ù„Ø¥Ø­ØµØ§Ø¡Ø§Øª (Ù‚Ø±Ø§Ø¡Ø© ÙÙ‚Ø·)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    def record_block(self):
        """ØªØ³Ø¬ÙŠÙ„ Ù…Ù†Ø¹ Ø¯Ø®ÙˆÙ„ (Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙ‚Ø·)"""
        self._stats["entries_blocked"] += 1
    
    def record_allow(self, recovery_reason=None):
        """ØªØ³Ø¬ÙŠÙ„ Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ (Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙ‚Ø·)"""
        self._stats["entries_allowed"] += 1
        if recovery_reason:
            self._stats["recovery_reasons"][recovery_reason] = \
                self._stats["recovery_reasons"].get(recovery_reason, 0) + 1
    
    def get_stats_summary(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ù„Ø®Øµ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ù„Ù„Ù‚Ø±Ø§Ø¡Ø© ÙÙ‚Ø·)"""
        total = self._stats["entries_blocked"] + self._stats["entries_allowed"]
        
        summary = {
            "entries_blocked": self._stats["entries_blocked"],
            "entries_allowed": self._stats["entries_allowed"],
            "block_percentage": (self._stats["entries_blocked"] / total * 100) if total > 0 else 0,
            "avg_block_seconds": (
                self._stats["total_block_duration"] / 
                max(self._stats["entries_blocked"], 1)
            ),
            "clear_reasons": dict(self._stats["clear_reasons"]),
            "recovery_reasons": dict(self._stats["recovery_reasons"])
        }
        return summary
```

2ï¸âƒ£ Ø´Ø±ÙˆØ· ØªØ¹Ø§ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚ (Ù…Ø­Ø³Ù‘Ù†Ø© ÙˆÙ…ØµØ­Ø­Ø©)

ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ø°Ø§ ØªØ­Ù‚Ù‚ Ø£ÙŠ Ø´Ø±Ø· ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·

```python
# ğŸ“ market_recovery.py

def market_recovered(guard):
    """
    ØªØ­Ø¯ÙŠØ¯ ØªØ¹Ø§ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    ÙŠÙØ±Ø¬Ø¹: (ØªØ¹Ø§ÙÙ‰: True/False, Ø§Ù„Ø³Ø¨Ø¨: str Ø£Ùˆ None)
    """
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1ï¸âƒ£ Ø§Ø®ØªØ±Ø§Ù‚ Ù‚Ù…Ø© Ø§Ù„Ø§Ø±ØªØ¯Ø§Ø¯ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    last_high = get_pullback_high_since_exit(guard)
    if last_high is not None and current_price > last_high:
        reason = f"breakout_above_{last_high:.4f}"
        log(f"[PEG] Recovery: {reason}")
        return True, reason

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2ï¸âƒ£ Higher Low Ù…Ø¤ÙƒÙ‘Ø¯
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if higher_low_confirmed(guard):
        reason = "higher_low_confirmed"
        log(f"[PEG] Recovery: {reason}")
        return True, reason

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3ï¸âƒ£ Ø¹ÙˆØ¯Ø© EMA20 ÙÙˆÙ‚ EMA50
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if ema20 > ema50:  # âœ… Ù…Ø¨Ø§Ø´Ø± ÙˆÙˆØ§Ø¶Ø­
        reason = "ema20_above_ema50"
        log(f"[PEG] Recovery: {reason}")
        return True, reason

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4ï¸âƒ£ Ø§Ø±ØªØ¯Ø§Ø¯ Ù‚ÙˆÙŠ ÙÙˆØ±ÙŠ (Ù„Ù„Ø£Ø³ÙˆØ§Ù‚ Ø§Ù„Ø³Ø±ÙŠØ¹Ø©)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    lowest_since_exit = get_lowest_price_since_exit(guard)
    if lowest_since_exit is not None:
        recovery_pct = ((current_price - lowest_since_exit) / lowest_since_exit) * 100
        
        if recovery_pct >= 1.5:
            reason = f"strong_recovery_{recovery_pct:.1f}%"
            log(f"[PEG] Recovery: {reason}")
            return True, reason

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # âŒ Ù„Ø§ ØªØ¹Ø§ÙÙŠ
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    return False, None


def get_pullback_high_since_exit(guard):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¹Ù„Ù‰ Ù‚Ù…Ø© ØªØ´ÙƒÙ„Øª Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ (pullback high)
    """
    if not guard.active or guard.exit_time is None:
        return None
    
    candles = get_candles_since(guard.exit_time)
    if len(candles) < 3:  # ØªØ­ØªØ§Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ 3 Ø´Ù…ÙˆØ¹ Ù„ØªØ´ÙƒÙŠÙ„ Ù‚Ù…Ø©
        return None
    
    # Ù†Ø£Ø®Ø° Ø¢Ø®Ø± 5 Ø´Ù…ÙˆØ¹ (Ø£Ùˆ Ø£Ù‚Ù„ Ø¥Ø°Ø§ Ø§Ù„Ù…ØªØ§Ø­ Ø£Ù‚Ù„)
    recent_candles = candles[-min(5, len(candles)):]
    return max(candle.high for candle in recent_candles)


def get_lowest_price_since_exit(guard):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¯Ù†Ù‰ Ø³Ø¹Ø± Ù…Ù†Ø° Ø§Ù„Ø®Ø±ÙˆØ¬
    """
    if not guard.active or guard.exit_time is None:
        return None
    
    candles = get_candles_since(guard.exit_time)
    if not candles:
        return None
    
    return min(candle.low for candle in candles)
```

3ï¸âƒ£ ØªØ¹Ø±ÙŠÙ Higher Low (ÙˆØ§Ø¶Ø­ ÙˆÙ…ØµØ­Ø­)

```python
def higher_low_confirmed(guard):
    """
    ØªØ£ÙƒÙŠØ¯ ØªÙƒÙˆÙŠÙ† Higher Low Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    """
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø³Ø§Ø¨Ù‚ (Ù‚Ø¨Ù„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ø£Ùˆ ÙÙŠ Ø¨Ø¯Ø§ÙŠØªÙ‡)
    prev_low = get_previous_swing_low(guard)
    if prev_low is None:
        return False
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ (Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬)
    curr_low = get_current_swing_low(guard)
    if curr_low is None:
        return False
    
    # Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„ØªØ­Ø³Ù†
    diff_pct = ((curr_low - prev_low) / prev_low) * 100
    
    # ØªØ£ÙƒÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ù…Ù†Ø° ØªØ´ÙƒÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ
    candles_since_current_low = count_candles_since_low(guard, curr_low)
    
    # Ø§Ù„Ø´Ø±ÙˆØ· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
    confirmed = (
        curr_low > prev_low and          # Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£Ø¹Ù„Ù‰
        diff_pct >= 0.3 and              # ÙØ±Ù‚ ÙƒØ§ÙÙ (0.3% Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„)
        candles_since_current_low >= 3   # ØªØ£ÙƒÙŠØ¯ Ø¨Ø¹Ø¯ 3 Ø´Ù…ÙˆØ¹
    )
    
    if confirmed:
        log(f"[PEG] Higher Low: {prev_low:.4f} â†’ {curr_low:.4f} (+{diff_pct:.2f}%)")
    
    return confirmed


def get_previous_swing_low(guard):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø³Ø§Ø¨Ù‚ (Ø¢Ø®Ø± swing low Ù‚Ø¨Ù„/Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø®Ø±ÙˆØ¬)
    """
    # Ù†Ø¨Ø­Ø« ÙÙŠ Ø¢Ø®Ø± 15 Ø´Ù…Ø¹Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø®Ø±ÙˆØ¬
    candles_before = get_candles(count=15, before=guard.exit_time)
    if not candles_before:
        return None
    
    # Ù†Ø¨Ø­Ø« Ø¹Ù† Ø£Ø¯Ù†Ù‰ Ù‚Ø§Ø¹ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©
    return min(candle.low for candle in candles_before)


def get_current_swing_low(guard):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    """
    candles_after = get_candles_since(guard.exit_time)
    if not candles_after:
        return None
    
    # Ù†Ø¨Ø­Ø« Ø¹Ù† Ø£Ø¯Ù†Ù‰ Ù‚Ø§Ø¹ Ù…Ù†Ø° Ø§Ù„Ø®Ø±ÙˆØ¬
    return min(candle.low for candle in candles_after)


def count_candles_since_low(guard, low_price):
    """
    Ø¹Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ù…Ù†Ø° ØªØ´ÙƒÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
    """
    candles = get_candles_since(guard.exit_time)
    if not candles:
        return 0
    
    # Ù†Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„ØªÙŠ Ø¨Ù‡Ø§ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø§Ø¹
    for i in range(len(candles)-1, -1, -1):
        if candles[i].low == low_price:
            # Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø¨Ø¹Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø´Ù…Ø¹Ø©
            return len(candles) - i - 1
    
    return 0  # Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¹
```

4ï¸âƒ£ Ø±Ø¨Ø· Ø§Ù„Ø­Ø§Ø±Ø³ Ø¨Ù…Ø³Ø§Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„ (Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„ÙˆØ­ÙŠØ¯Ø©)

```python
def try_open_trade(signal):
    """
    Ù…Ø­Ø§ÙˆÙ„Ø© ÙØªØ­ ØµÙÙ‚Ø© Ù…Ø¹ ØªØ·Ø¨ÙŠÙ‚ Ø­Ø§Ø±Ø³ Ù…Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    """
    guard = PostExitGuard.get()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Ø­Ø§Ù„Ø© 1: Ø­Ø§Ø±Ø³ ØºÙŠØ± Ù†Ø´Ø· â†’ Ø¯Ø®ÙˆÙ„ Ø·Ø¨ÙŠØ¹ÙŠ
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if not guard.active:
        guard.record_allow("no_guard_active")
        return open_trade(signal)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Ø­Ø§Ù„Ø© 2: Ø­Ø§Ø±Ø³ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© â†’ Ø¥Ø²Ø§Ù„Ø© ÙˆØ¯Ø®ÙˆÙ„
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if guard.expired():
        guard.clear("max_duration_reached")
        guard.record_allow("guard_expired")
        return open_trade(signal)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Ø­Ø§Ù„Ø© 3: Ø­Ø§Ø±Ø³ Ù†Ø´Ø· â†’ ØªÙ‚ÙŠÙŠÙ… ØªØ¹Ø§ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    recovered, recovery_reason = market_recovered(guard)
    
    if not recovered:
        # âŒ Ù…Ù†Ø¹ Ø§Ù„Ø¯Ø®ÙˆÙ„
        guard.record_block()
        log(f"[PEG] Entry BLOCKED | market not recovered")
        return None
    else:
        # âœ… Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„
        guard.clear(f"recovered_{recovery_reason}")
        guard.record_allow(recovery_reason)
        log(f"[PEG] Entry ALLOWED | {recovery_reason}")
        return open_trade(signal)
```

ğŸ“Œ ØªØ­Ø°ÙŠØ± Ù…Ù‡Ù…: Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙ†ÙÙŠØ°

Ø¶Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†Ø·Ù‚ ÙÙŠ:
âœ… try_open_trade() ÙÙ‚Ø· (Ø¢Ø®Ø± Ù†Ù‚Ø·Ø© Ù‚Ø¨Ù„ open_trade())

Ù„Ø§ ØªØ¶Ø¹Ù‡ ÙÙŠ:
âŒ generate_signals()
âŒ calculate_scores()
âŒ analyze_market()
âŒ Ø£ÙŠ Ù…ÙƒØ§Ù† Ø¢Ø®Ø±

5ï¸âƒ£ Ø±Ø¨Ø· Ø§Ù„Ø­Ø§Ø±Ø³ Ø¨Ø§Ù„Ø®Ø±ÙˆØ¬ (Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·)

```python
# Ø¯Ø§Ø®Ù„ exit_trade() - âŒ Ù„Ø§ ØªØºÙŠÙŠØ± Ø£ÙŠ Ø´ÙŠØ¡ Ø¢Ø®Ø±
def exit_trade(trade, reason):
    # ... Ù…Ù†Ø·Ù‚ Ø§Ù„Ø®Ø±ÙˆØ¬ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± ...
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # âœ… Ø¥Ø¶Ø§ÙØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ù‡Ù†Ø§:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PostExitGuard.get().record_exit(
        exit_price=trade.exit_price,
        timestamp=now()
    )
    
    # ... Ø¨Ø§Ù‚ÙŠ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø®Ø±ÙˆØ¬ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ ...
```

âŒ Ù„Ø§ ØªØºÙŠÙŠØ± Ø³Ø¨Ø¨ Ø§Ù„Ø®Ø±ÙˆØ¬
âŒ Ù„Ø§ Ù…Ù†Ø¹ Stop Loss
âŒ Ù„Ø§ Ù„Ù…Ø³ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø±

ğŸ§ª Ø³Ù„ÙˆÙƒ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­

âŒ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ù‚Ø¯ÙŠÙ… (ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ®ØªÙÙŠ)

```
Exit ØµØ­ÙŠØ­  
â†“  
Enter ÙÙˆØ±Ù‹Ø§  
â†“  
Exit Ø®Ø³Ø§Ø±Ø©  
```

âœ… Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ø§Ù„Ù…ØªÙˆÙ‚Ø¹)

```
Exit ØµØ­ÙŠØ­  
â†“  
[PEG] Entry BLOCKED | market not recovered  
â†“  
(Ø§Ù†ØªØ¸Ø§Ø± Ø°ÙƒÙŠ Ø­ØªÙ‰ ÙŠØªØ­Ù‚Ù‚ Ø´Ø±Ø· ÙˆØ§Ø­Ø¯)  
â†“  
[PEG] Recovery detected: [breakout/higher_low/ema/recovery]  
â†“  
Enter ÙˆØ§Ø­Ø¯ Ù†Ø¸ÙŠÙ ÙÙŠ Ø§Ù„ØªÙˆÙ‚ÙŠØª Ø§Ù„ØµØ­ÙŠØ­  
```

ğŸ›¡ï¸ Ø¶Ù…Ø§Ù†Ø§Øª Ø§Ù„Ø³Ù„Ø§Ù…Ø©

Â· âœ… Ù„Ø§ Ù…Ù†Ø¹ Ø¯Ø§Ø¦Ù… (Ø­Ø¯ Ø£Ù‚ØµÙ‰ Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹)
Â· âœ… Ù„Ø§ ØªØ£Ø®ÙŠØ± Ø²Ù…Ù†ÙŠ Ø«Ø§Ø¨Øª (ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙˆÙ‚ ÙÙ‚Ø·)
Â· âœ… Ù„Ø§ Ù‚ØªÙ„ Ù„Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© (ÙŠØ¹ÙˆØ¯ ÙÙˆØ± ØªØ­Ø³Ù† Ø§Ù„Ø³ÙˆÙ‚)
Â· âœ… Ø¯Ø®ÙˆÙ„ ÙÙˆØ±ÙŠ Ø¹Ù†Ø¯ Ø£ÙˆÙ„ ØªØ¹Ø§ÙÙŠ Ø­Ù‚ÙŠÙ‚ÙŠ
Â· âœ… ØªÙƒÙ„ÙØ© ØªÙ†ÙÙŠØ° â‰ˆ ØµÙØ± (Ù„Ø§ Ù…Ø¤Ø´Ø±Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©)
Â· âœ… Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø±Ø§Ø¡Ø© ÙÙ‚Ø· (Ù„Ø§ ØªØ¤Ø«Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª)

ğŸ§¾ Ù„ÙˆÙ‚ ØªØ´Ø®ÙŠØµÙŠ Ù…Ø¤Ù‚Øª (Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±)

```python
# ğŸ“ peg_debug.py (ÙŠØ­Ø°Ù Ø¨Ø¹Ø¯ 48 Ø³Ø§Ø¹Ø©)

PEG_DEBUG_ENABLED = True  # âš ï¸ Ø¶Ø¹ False Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯

def log_peg_debug_info():
    """ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ØªØ´Ø®ÙŠØµÙŠØ© Ù„Ù„Ø­Ø§Ø±Ø³"""
    if not PEG_DEBUG_ENABLED:
        return
    
    guard = PostExitGuard.get()
    
    if not guard.active:
        log(f"[PEG DEBUG] Guard inactive")
        return
    
    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
    time_since_exit = now() - guard.exit_time
    log(f"[PEG DEBUG] Active for {time_since_exit:.1f}s")
    log(f"[PEG DEBUG] Exit price: {guard.exit_price:.4f}, Current: {current_price:.4f}")
    
    # Ø­Ø§Ù„Ø© Ø§Ù„Ø´Ø±ÙˆØ·
    last_high = get_pullback_high_since_exit(guard)
    hl_confirmed = higher_low_confirmed(guard)
    lowest = get_lowest_price_since_exit(guard)
    
    log(f"[PEG DEBUG] Pullback high: {last_high:.4f if last_high else 'N/A'}")
    log(f"[PEG DEBUG] Higher Low: {hl_confirmed}")
    log(f"[PEG DEBUG] Lowest since exit: {lowest:.4f if lowest else 'N/A'}")
    log(f"[PEG DEBUG] EMA20 > EMA50: {ema20 > ema50}")
    
    # ØªÙ‚ÙŠÙŠÙ… ØªØ¹Ø§ÙÙŠ
    recovered, reason = market_recovered(guard)
    log(f"[PEG DEBUG] Market recovered: {recovered} ({reason or 'N/A'})")
```

ğŸ—‘ï¸ ÙŠÙØ­Ø°Ù Ù…Ù„Ù peg_debug.py Ø¨Ø¹Ø¯ 48 Ø³Ø§Ø¹Ø© Ù…Ù† Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙ‚Ø±

ğŸ“Š Ù„ÙˆØ­Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© ÙŠØ¯ÙˆÙŠØ© (Ù„Ù„ØªØ­Ù„ÙŠÙ„ ÙÙ‚Ø·)

```python
# ğŸ“ peg_monitor.py (ØªØ´ØºÙŠÙ„ ÙŠØ¯ÙˆÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©)

def show_peg_monitor():
    """
    Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø£Ø¯Ø§Ø¡ PEG (Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙŠØ¯ÙˆÙŠ ÙÙ‚Ø·)
    """
    guard = PostExitGuard.get()
    stats = guard.get_stats_summary()
    
    print("\n" + "="*60)
    print("ğŸ“Š POST-EXIT GUARD MONITOR (READ-ONLY)")
    print("="*60)
    
    print(f"\nğŸ“ˆ Entry Decisions:")
    print(f"   Allowed: {stats['entries_allowed']}")
    print(f"   Blocked: {stats['entries_blocked']}")
    print(f"   Block %: {stats['block_percentage']:.1f}%")
    
    print(f"\nâ±ï¸ Block Durations:")
    print(f"   Average: {stats['avg_block_seconds']:.1f}s")
    print(f"   Total: {stats['total_block_seconds']:.1f}s")
    
    if stats['recovery_reasons']:
        print(f"\nâœ… Recovery Reasons:")
        for reason, count in sorted(stats['recovery_reasons'].items()):
            print(f"   {reason}: {count}")
    
    if stats['clear_reasons']:
        print(f"\nğŸ—‘ï¸ Clear Reasons:")
        for reason, count in sorted(stats['clear_reasons'].items()):
            print(f"   {reason}: {count}")
    
    print("\n" + "="*60)
    print("âš ï¸ Note: Statistics are read-only, never affect decisions")
    print("="*60)
```

ğŸ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©

Â· âœ… Ù„Ø§ Ø¯Ø®ÙˆÙ„ ØºØ¨ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
Â· âœ… Ù„Ø§ Ø­Ø±Ù‚ Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ ÙÙŠ Ø³ÙˆÙ‚ Ø³ÙŠØ¦
Â· âœ… Ø¯Ø®ÙˆÙ„ Ø£Ù‚Ù„ Ù„ÙƒÙ† Ø£Ø¹Ù„Ù‰ Ø¬ÙˆØ¯Ø©
Â· âœ… ØµÙÙ‚Ø§Øª Ø£ÙˆØ¶Ø­ ÙˆØ£ÙƒØ«Ø± ØªØ±ÙƒÙŠØ²Ø§Ù‹
Â· âœ… Ù†ÙØ³ Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ©â€¦ Ù„ÙƒÙ† Ø¨ØªÙˆÙ‚ÙŠØª ØµØ­ÙŠØ­

---

â±ï¸ Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©

1. Ø§Ù„ØªÙ†ÙÙŠØ°
   ```bash
   â”œâ”€â”€ post_exit_guard.py      # Ø§Ù„Ø­Ø§Ø±Ø³ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
   â”œâ”€â”€ market_recovery.py      # Ø´Ø±ÙˆØ· Ø§Ù„ØªØ¹Ø§ÙÙŠ
   â”œâ”€â”€ peg_debug.py           # ğŸ”¥ ØªØ´ØºÙŠÙ„ Ø£ÙˆÙ„ 48 Ø³Ø§Ø¹Ø© ÙÙ‚Ø·
   â””â”€â”€ peg_monitor.py         # âš ï¸ ØªØ´ØºÙŠÙ„ ÙŠØ¯ÙˆÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
   ```
2. Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
   Â· Backtest Ø³Ø±ÙŠØ¹ (3 Ø£ÙŠØ§Ù…)
   Â· Paper Trading (48 Ø³Ø§Ø¹Ø© Ù…Ø¹ DEBUG_ENABLED=True)
3. Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
   Â· ØªØ´ØºÙŠÙ„ show_peg_monitor() Ø¨Ø¹Ø¯ 100 Ù‚Ø±Ø§Ø±
   Â· ØªØ£ÙƒØ¯ Ù…Ù†:
     Â· Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ over-blocking
     Â· Ø³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„ØªØ¹Ø§ÙÙŠ
4. Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
   Â· ØªØ¹Ø·ÙŠÙ„ DEBUG_ENABLED
   Â· Ø­Ø°Ù peg_debug.py
   Â· Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„
5. Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
   Â· Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
   Â· Ø¶Ø¨Ø· Ø¨Ø³ÙŠØ· Ù„Ù„Ù†Ø³Ø¨ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± (1.5% â†’ 1.2% Ø§Ù„Ø®)